<<<<<<< HEAD
C:\Program Files (x86)\360

=======
>>>>>>> 465d8d2167a10d4cc2ddd5452fd4126901c18f1b
undefined：
1.获取对象中不存在的属性
2.变量声明且没有赋值
3.函数有形参但没有传入实参，形参的值是undefined
4.函数内部没有return，或return后面没有任何东西，调用函数后接到的值是undefined
D:\GitGUI\bin\TortoiseGitPlink.exe
null：
对象不存在

null是一个独立的数据类型，typeof返回的是Object，js一切皆对象，设计时的错误，解析引擎解析的是object，undefined是"空"的补充

数组的声明：
直接量（字面量）var arr=[1,2];
使用内置构造函数 var arr=new Array();
js中没有关联数组 var arr=['a'=>1,'b'=>2];（语法错误）

for(var i=0;i<ar.length;i++)
for(i in arr)
arr.forEach(function(v,k,h){
//接收一个函数（回调函数）参数
})

包装对象：操作字符串、数字或布尔值的属性时创建的临时对象称作包装对象。

对象的声明：
var obj={name:"a",age:1,fun:function(){//函数属性}}
obj.fun	//obj的fun属性
obj.fun()	//执行函数
console.log(obj.fun())  //输出：undefined（函数没有return）

函数的声明：
直接量：function f1(){}
表达式声明：var f2=function(){}
内置构造函数：var f3=new function(){}	//一般不用
直接量和表达式的区别：表达式必须在声明后才能调用，直接量可以随时调用
f2();    f3();

一切皆对象；
一等公民函数；

//在js中函数自身的作用域在声明的地方，而不是调用的地方
var a=1;
function f1(f2){
    var a=2;
    f2();
}
function f2(){
    console.log(a);
}
f1(f2);//输出1（f2是回调函数，执行a）

var a=2;
function f1(f2){
    var a=1;
    function f2(){
        console.log(a);
    }
    return f2;
}
var f=f1();
f();	//输出1


两链一包

Object的父级对象是null，Object是所有的父级对象

获取对象的原型：
o.__proto__.__proto__==null;




node.js
运行环境：cmd，编辑器终端，node终端
REPL环境：浏览器控制台

浏览器提供给js的API
浏览器操控类：弹窗、页面跳转
dom操作类：获取、删除、创建标签
网络操控类：ajax
...

提供给node的API（操作系统的API接口）
核心模块：安装就有的
第三方模块：自己下载的
自定义模块：自己写的

异步

apache是一个http服务器

this在哪个作用域下运行就指向哪个

绑定事件的几种方式：
<button onclick=""></button>
document.getElementById("btn").onclick

浏览器接收客户端请求
1.接收html页面
2.接收静态资源
3.接收异步数据

node的时间第三方模块：moment

package.json记录了项目的所信息和管理所有的第三方包模块
直接npm install可以安装

事件处理：
捕获->目标->冒泡
d2.addEventListener('click',function(){
        alert("d2");
    },false);
    d3.addEventListener('click',function(){
        alert("d3");
    },true);
addEventListener：捕获阶段触发（true为捕获阶段，false为冒泡阶段）

客户端渲染（AJAX）
服务端窜然

npm install nodemon -g
自启动
nodemon http.js

W3C+ECMAScript提供了浏览器的js规范
CommonJS提供了后端js规范

W3C：BOM、DOM
浏览器：BOM、DOM、ECMAScript
Node：ECMAScript、FS、TCP 、Stream、Buffer......
CommonJS：FS、TCP 、Stream、Buffer

node编写模块：
模块引入：require()

模块定义：
在模块中使用exports对象导出当前模块或数据方法
模块中还存在一个module对象，他代表模块自身，module有一个exports属性，用于数据导出
其实exports对象就是module.exports的引用；exports===module.exports

模块的标识：
其实就是模块的名字，必须符合小驼峰命名规则，使用require()引入时使用 . 或 .. 开头的相对路径或
 / 开头的绝对路径，引入时可以不写文件后缀名

注意：模块中的方法和变量的作用域只在模块的内部，每个模块具有独立的空间，互不干扰

module.exports和exports的区别：
module.exports直接赋值就会被导出：module.exports={data:78}
exports直接赋值不会导出：exports.data=78

模块加载的顺序和规则：
1.优先从缓存加载
2.核心模块优先于第三方模块，自定义模块有路径区别
模块的入口文件在package.json的main
如果没有package.json或没有main属性，会默认去看下moment目录中有没有index.js->index.json->index.node文件，如果没找到index或moment或者找不到node_moduls,则进入上一级目录找node_moudls查找（规则同上），如果上一级还找不到，继续向上，一直到当前文件所属磁盘的根目录，如果到磁盘根目录还没找到，直接报错
当前目录没有往上一层目录找

nodemon http.js

res.urls：获取url
res.methd：获取请求的方法
获取url的参数：
var url=require("url");//引入url核心模块
var urls=res.url;//获取请求的url
url.parse(urls,true).query;//获取各个参数，true将得到的query变为对象

url.pathname//url的路径
当select需要用到id时，exports只能导出属性，传参得用回调函数

链式操作（点带点）的原理：return this;
db.xx().ee().ff().o();
前面几个必须return this;最后一个必须不能return this;










